/**
 * generated by Xtext
 */
package org.xtext.simplesonora.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.io.File;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.jfugue.midi.MidiFileManager;
import org.jfugue.pattern.Pattern;
import org.jfugue.player.Player;
import org.xtext.simplesonora.simpleSonora.Chord;
import org.xtext.simplesonora.simpleSonora.Harmony;
import org.xtext.simplesonora.simpleSonora.Header;
import org.xtext.simplesonora.simpleSonora.Instrument;
import org.xtext.simplesonora.simpleSonora.Note;
import org.xtext.simplesonora.simpleSonora.Sequence;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class SimpleSonoraGenerator implements IGenerator {
  private String songName = new String("");
  
  private String key = new String("");
  
  private boolean feedback = true;
  
  private Integer curVoice = Integer.valueOf(0);
  
  private Integer curOctave = Integer.valueOf(4);
  
  private String curDuration = new String("h");
  
  private boolean keepTie = false;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    try {
      final Player player = new Player();
      final Pattern pattern = new Pattern();
      TreeIterator<EObject> _allContents = resource.getAllContents();
      Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
      Iterable<Header> _filter = Iterables.<Header>filter(_iterable, Header.class);
      for (final Header h : _filter) {
        {
          this.feedback = true;
          String _songName = h.getSongName();
          this.songName = _songName;
          int _tempo = h.getTempo();
          boolean _greaterThan = (_tempo > 0);
          if (_greaterThan) {
            int _tempo_1 = h.getTempo();
            pattern.setTempo(_tempo_1);
          }
          String _key = h.getKey();
          boolean _notEquals = (!Objects.equal(_key, null));
          if (_notEquals) {
            String _key_1 = h.getKey();
            String _keyToPattern = this.keyToPattern(_key_1);
            pattern.add(_keyToPattern);
          }
          boolean _isNofeedback = h.isNofeedback();
          if (_isNofeedback) {
            this.feedback = false;
          }
        }
      }
      this.curVoice = Integer.valueOf(0);
      TreeIterator<EObject> _allContents_1 = resource.getAllContents();
      Iterable<EObject> _iterable_1 = IteratorExtensions.<EObject>toIterable(_allContents_1);
      Iterable<Instrument> _filter_1 = Iterables.<Instrument>filter(_iterable_1, Instrument.class);
      for (final Instrument instrument : _filter_1) {
        {
          this.curDuration = "h";
          this.curOctave = Integer.valueOf(4);
          pattern.add(("V" + this.curVoice));
          String _instrumentName = instrument.getInstrumentName();
          String _plus = ("I[" + _instrumentName);
          String _plus_1 = (_plus + "]");
          pattern.add(_plus_1);
          EList<Sequence> _sequences = instrument.getSequences();
          for (final Sequence s : _sequences) {
            {
              Note _note = s.getNote();
              boolean _notEquals = (!Objects.equal(_note, null));
              if (_notEquals) {
                Note _note_1 = s.getNote();
                String _noteToPattern = this.noteToPattern(_note_1);
                pattern.add(_noteToPattern);
              }
              Chord _chord = s.getChord();
              boolean _notEquals_1 = (!Objects.equal(_chord, null));
              if (_notEquals_1) {
                Chord _chord_1 = s.getChord();
                String _chordToPattern = this.chordToPattern(_chord_1);
                pattern.add(_chordToPattern);
              }
              Harmony _harmony = s.getHarmony();
              boolean _notEquals_2 = (!Objects.equal(_harmony, null));
              if (_notEquals_2) {
                Harmony _harmony_1 = s.getHarmony();
                String _harmonyToPattern = this.harmonyToPattern(_harmony_1);
                pattern.add(_harmonyToPattern);
              }
            }
          }
          this.curVoice++;
        }
      }
      if (this.feedback) {
        player.play(pattern);
      }
      String _string = pattern.toString();
      System.out.println(_string);
      File _file = new File((this.songName + ".mid"));
      MidiFileManager.savePatternToMidi(pattern, _file);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * Converts the Simple-Sonora key signature pattern to the JFugue pattern.
   * 
   * @param k	String containing.
   * @return String with JFugue Pattern notation for key signature.
   */
  public String keyToPattern(final String k) {
    this.key = "KEY:";
    char _charAt = k.charAt(0);
    char _upperCase = Character.toUpperCase(_charAt);
    String _string = Character.valueOf(_upperCase).toString();
    String _concat = this.key.concat(_string);
    this.key = _concat;
    char _charAt_1 = k.charAt(1);
    int _compareTo = Character.valueOf(_charAt_1).compareTo(Character.valueOf('+'));
    boolean _equals = (_compareTo == 0);
    if (_equals) {
      String _concat_1 = this.key.concat("#");
      this.key = _concat_1;
    } else {
      char _charAt_2 = k.charAt(1);
      int _compareTo_1 = Character.valueOf(_charAt_2).compareTo(Character.valueOf('-'));
      boolean _equals_1 = (_compareTo_1 == 0);
      if (_equals_1) {
        String _concat_2 = this.key.concat("b");
        this.key = _concat_2;
      }
    }
    String _substring = k.substring(2);
    String _trim = _substring.trim();
    String _concat_3 = this.key.concat(_trim);
    this.key = _concat_3;
    return this.key;
  }
  
  /**
   * Changes the current octave accordingly to the octave operator used.
   * 
   * @param o String containing the octave information.
   */
  public void setOctave(final String o) {
    int _compareTo = o.compareTo(">");
    boolean _equals = (_compareTo == 0);
    if (_equals) {
      this.curOctave++;
    } else {
      int _compareTo_1 = o.compareTo("<");
      boolean _equals_1 = (_compareTo_1 == 0);
      if (_equals_1) {
        this.curOctave--;
      } else {
        char _charAt = o.charAt(1);
        String _string = Character.valueOf(_charAt).toString();
        int _parseInt = Integer.parseInt(_string);
        this.curOctave = Integer.valueOf(_parseInt);
      }
    }
  }
  
  /**
   * Converts from Simple-Sonora note pattern to the JFugue one.
   * 
   * @param note Note containing note id, accidental and duration.
   * @return String with JFugue pattern notation for notes.
   */
  public String noteToPattern(final Note note) {
    String _octave = note.getOctave();
    boolean _notEquals = (!Objects.equal(_octave, null));
    if (_notEquals) {
      String _octave_1 = note.getOctave();
      this.setOctave(_octave_1);
    }
    String _note = note.getNote();
    String auxNote = _note.toUpperCase();
    String _accidental = note.getAccidental();
    boolean _notEquals_1 = (!Objects.equal(_accidental, null));
    if (_notEquals_1) {
      String _accidental_1 = note.getAccidental();
      String _accidentalToPattern = this.accidentalToPattern(_accidental_1);
      String _concat = auxNote.concat(_accidentalToPattern);
      auxNote = _concat;
    }
    String _duration = note.getDuration();
    boolean _notEquals_2 = (!Objects.equal(_duration, null));
    if (_notEquals_2) {
      String _duration_1 = note.getDuration();
      String _durationToPattern = this.durationToPattern(_duration_1);
      this.curDuration = _durationToPattern;
    }
    String point = "";
    boolean _isPoint = note.isPoint();
    if (_isPoint) {
      point = ".";
    }
    String tie = "";
    String tied = "";
    boolean _isTie = note.isTie();
    if (_isTie) {
      tie = "-";
      if (this.keepTie) {
        tied = "-";
      }
      this.keepTie = true;
    } else {
      if (this.keepTie) {
        tied = "-";
        this.keepTie = false;
      }
    }
    String _note_1 = note.getNote();
    boolean _equalsIgnoreCase = _note_1.equalsIgnoreCase("r");
    if (_equalsIgnoreCase) {
      String _concat_1 = auxNote.concat((((tied + this.curDuration) + point) + tie));
      auxNote = _concat_1;
    } else {
      String _string = this.curOctave.toString();
      String _plus = (_string + tied);
      String _plus_1 = (_plus + this.curDuration);
      String _plus_2 = (_plus_1 + point);
      String _plus_3 = (_plus_2 + tie);
      String _concat_2 = auxNote.concat(_plus_3);
      auxNote = _concat_2;
    }
    return auxNote;
  }
  
  public String chordToPattern(final Chord chord) {
    String auxChord = "";
    EList<Note> _chordNotes = chord.getChordNotes();
    List<Note> _list = IterableExtensions.<Note>toList(_chordNotes);
    for (final Note n : _list) {
      String _noteToPattern = this.noteToPattern(n);
      String _plus = (_noteToPattern + "+");
      String _concat = auxChord.concat(_plus);
      auxChord = _concat;
    }
    int _length = auxChord.length();
    int _minus = (_length - 1);
    return auxChord.substring(0, _minus);
  }
  
  public String harmonyToPattern(final Harmony harmony) {
    String h = "";
    EList<Note> _harmonyNotes = harmony.getHarmonyNotes();
    List<Note> _list = IterableExtensions.<Note>toList(_harmonyNotes);
    for (final Note n : _list) {
      String _noteToPattern = this.noteToPattern(n);
      String _plus = (_noteToPattern + "+");
      String _concat = h.concat(_plus);
      h = _concat;
    }
    EList<Note> _notes = harmony.getNotes();
    List<Note> _list_1 = IterableExtensions.<Note>toList(_notes);
    for (final Note n_1 : _list_1) {
      String _noteToPattern_1 = this.noteToPattern(n_1);
      String _plus_1 = (_noteToPattern_1 + "_");
      String _concat_1 = h.concat(_plus_1);
      h = _concat_1;
    }
    int _length = h.length();
    int _minus = (_length - 1);
    return h.substring(0, _minus);
  }
  
  /**
   * Converts Simple-Sonora to JFugue duration pattern.
   * 
   * @param dur Simple-Sonora notation for duration.
   * @return JFugue notation for duration.
   */
  public String durationToPattern(final String dur) {
    switch (dur) {
      case ":1":
        return "w";
      case ":2":
        return "h";
      case ":4":
        return "q";
      case ":8":
        return "i";
      case ":16":
        return "s";
      case ":32":
        return "t";
      case ":64":
        return "x";
      case ":128":
        return "o";
    }
    return "";
  }
  
  /**
   * Converts Simple-Sonora to JFugue accidental pattern.
   * 
   * @param acc Simple-Sonora accidental notation.
   * @return JFugue accidental notation.
   */
  public String accidentalToPattern(final String acc) {
    switch (acc) {
      case "+":
        return "#";
      case "-":
        return "b";
      case "@":
        return "n";
    }
    return acc;
  }
}
