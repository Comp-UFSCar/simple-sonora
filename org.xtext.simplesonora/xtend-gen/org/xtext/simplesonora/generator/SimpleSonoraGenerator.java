/**
 * generated by Xtext
 */
package org.xtext.simplesonora.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.io.File;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.jfugue.midi.MidiFileManager;
import org.jfugue.pattern.Pattern;
import org.jfugue.player.Player;
import org.xtext.simplesonora.simpleSonora.Chord;
import org.xtext.simplesonora.simpleSonora.Harmony;
import org.xtext.simplesonora.simpleSonora.Header;
import org.xtext.simplesonora.simpleSonora.Instrument;
import org.xtext.simplesonora.simpleSonora.Key;
import org.xtext.simplesonora.simpleSonora.Note;
import org.xtext.simplesonora.simpleSonora.Sequence;
import org.xtext.simplesonora.simpleSonora.Tempo;
import org.xtext.simplesonora.simpleSonora.Tuplet;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class SimpleSonoraGenerator implements IGenerator {
  private String songName = new String("");
  
  private String key = new String("");
  
  private boolean feedback = true;
  
  private Integer curVoice = Integer.valueOf(0);
  
  private Integer curOctave = Integer.valueOf(4);
  
  private String curDuration = new String("h");
  
  private boolean keepTie = false;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    try {
      final Player player = new Player();
      final Pattern pattern = new Pattern();
      TreeIterator<EObject> _allContents = resource.getAllContents();
      Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
      Iterable<Header> _filter = Iterables.<Header>filter(_iterable, Header.class);
      for (final Header h : _filter) {
        {
          this.feedback = true;
          String _songName = h.getSongName();
          this.songName = _songName;
          Tempo _tempo = h.getTempo();
          boolean _notEquals = (!Objects.equal(_tempo, null));
          if (_notEquals) {
            Tempo _tempo_1 = h.getTempo();
            int _value = _tempo_1.getValue();
            boolean _greaterThan = (_value > 0);
            if (_greaterThan) {
              Tempo _tempo_2 = h.getTempo();
              int _value_1 = _tempo_2.getValue();
              pattern.setTempo(_value_1);
            } else {
              Tempo _tempo_3 = h.getTempo();
              String _id = _tempo_3.getId();
              pattern.setTempo(_id);
            }
          }
          Key _key = h.getKey();
          boolean _notEquals_1 = (!Objects.equal(_key, null));
          if (_notEquals_1) {
            Key _key_1 = h.getKey();
            String _keyToPattern = this.keyToPattern(_key_1);
            pattern.add(_keyToPattern);
          }
          boolean _isNofeedback = h.isNofeedback();
          if (_isNofeedback) {
            this.feedback = false;
          }
        }
      }
      this.curVoice = Integer.valueOf(0);
      TreeIterator<EObject> _allContents_1 = resource.getAllContents();
      Iterable<EObject> _iterable_1 = IteratorExtensions.<EObject>toIterable(_allContents_1);
      Iterable<Instrument> _filter_1 = Iterables.<Instrument>filter(_iterable_1, Instrument.class);
      for (final Instrument instrument : _filter_1) {
        EList<Sequence> _sequences = instrument.getSequences();
        int _length = ((Object[])Conversions.unwrapArray(_sequences, Object.class)).length;
        boolean _greaterThan = (_length > 0);
        if (_greaterThan) {
          this.curDuration = "h";
          this.curOctave = Integer.valueOf(4);
          pattern.add(("V" + this.curVoice));
          String _instrumentName = instrument.getInstrumentName();
          String _plus = ("I[" + _instrumentName);
          String _plus_1 = (_plus + "]");
          pattern.add(_plus_1);
          EList<Sequence> _sequences_1 = instrument.getSequences();
          for (final Sequence s : _sequences_1) {
            {
              Note _note = s.getNote();
              boolean _notEquals = (!Objects.equal(_note, null));
              if (_notEquals) {
                Note _note_1 = s.getNote();
                String _noteToPattern = this.noteToPattern(_note_1);
                pattern.add(_noteToPattern);
              }
              Chord _chord = s.getChord();
              boolean _notEquals_1 = (!Objects.equal(_chord, null));
              if (_notEquals_1) {
                Chord _chord_1 = s.getChord();
                String _chordToPattern = this.chordToPattern(_chord_1);
                pattern.add(_chordToPattern);
              }
              Harmony _harmony = s.getHarmony();
              boolean _notEquals_2 = (!Objects.equal(_harmony, null));
              if (_notEquals_2) {
                Harmony _harmony_1 = s.getHarmony();
                String _harmonyToPattern = this.harmonyToPattern(_harmony_1);
                pattern.add(_harmonyToPattern);
              }
              Tuplet _tuplet = s.getTuplet();
              boolean _notEquals_3 = (!Objects.equal(_tuplet, null));
              if (_notEquals_3) {
                Tuplet _tuplet_1 = s.getTuplet();
                String _tuppletToPattern = this.tuppletToPattern(_tuplet_1);
                pattern.add(_tuppletToPattern);
              }
            }
          }
          this.curVoice++;
        }
      }
      if (this.feedback) {
        player.play(pattern);
      }
      String _string = pattern.toString();
      System.out.println(_string);
      File _file = new File((this.songName + ".mid"));
      MidiFileManager.savePatternToMidi(pattern, _file);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * Converts the Simple-Sonora key signature pattern to the JFugue pattern.
   * 
   * @param k	Key containing the key for the song.
   * @return String with JFugue Pattern notation for key signature.
   */
  public String keyToPattern(final Key k) {
    this.key = "KEY:";
    String _note = k.getNote();
    String _upperCase = _note.toUpperCase();
    String _concat = this.key.concat(_upperCase);
    this.key = _concat;
    String _accidental = k.getAccidental();
    boolean _notEquals = (!Objects.equal(_accidental, null));
    if (_notEquals) {
      String _accidental_1 = k.getAccidental();
      switch (_accidental_1) {
        case "+":
          String _concat_1 = this.key.concat("#");
          this.key = _concat_1;
          break;
        case "-":
          String _concat_2 = this.key.concat("b");
          this.key = _concat_2;
          break;
      }
    }
    String _interval = k.getInterval();
    String _substring = _interval.substring(0, 3);
    String _concat_3 = this.key.concat(_substring);
    this.key = _concat_3;
    return this.key;
  }
  
  /**
   * Changes the current octave accordingly to the octave operator used.
   * 
   * @param o String containing the octave information.
   */
  public void setOctave(final String o) {
    int _compareTo = o.compareTo(">");
    boolean _equals = (_compareTo == 0);
    if (_equals) {
      this.curOctave++;
    } else {
      int _compareTo_1 = o.compareTo("<");
      boolean _equals_1 = (_compareTo_1 == 0);
      if (_equals_1) {
        this.curOctave--;
      } else {
        char _charAt = o.charAt(1);
        String _string = Character.valueOf(_charAt).toString();
        int _parseInt = Integer.parseInt(_string);
        this.curOctave = Integer.valueOf(_parseInt);
      }
    }
  }
  
  /**
   * Converts from Simple-Sonora note pattern to the JFugue one.
   * 
   * @param note Note containing note id, accidental and duration.
   * @return String with JFugue pattern notation for notes.
   */
  public String noteToPattern(final Note note) {
    String _octave = note.getOctave();
    boolean _notEquals = (!Objects.equal(_octave, null));
    if (_notEquals) {
      String _octave_1 = note.getOctave();
      this.setOctave(_octave_1);
    }
    String _note = note.getNote();
    String auxNote = _note.toUpperCase();
    String _accidental = note.getAccidental();
    boolean _notEquals_1 = (!Objects.equal(_accidental, null));
    if (_notEquals_1) {
      String _accidental_1 = note.getAccidental();
      String _accidentalToPattern = this.accidentalToPattern(_accidental_1);
      String _concat = auxNote.concat(_accidentalToPattern);
      auxNote = _concat;
    }
    String _duration = note.getDuration();
    boolean _notEquals_2 = (!Objects.equal(_duration, null));
    if (_notEquals_2) {
      String _duration_1 = note.getDuration();
      String _durationToPattern = this.durationToPattern(_duration_1);
      this.curDuration = _durationToPattern;
    }
    String point = "";
    boolean _isPoint = note.isPoint();
    if (_isPoint) {
      point = ".";
    }
    String tie = "";
    String tied = "";
    boolean _isTie = note.isTie();
    if (_isTie) {
      tie = "-";
      if (this.keepTie) {
        tied = "-";
      }
      this.keepTie = true;
    } else {
      if (this.keepTie) {
        tied = "-";
        this.keepTie = false;
      }
    }
    String _note_1 = note.getNote();
    boolean _equalsIgnoreCase = _note_1.equalsIgnoreCase("r");
    if (_equalsIgnoreCase) {
      String _concat_1 = auxNote.concat((((tied + this.curDuration) + point) + tie));
      auxNote = _concat_1;
    } else {
      String _string = this.curOctave.toString();
      String _plus = (_string + tied);
      String _plus_1 = (_plus + this.curDuration);
      String _plus_2 = (_plus_1 + point);
      String _plus_3 = (_plus_2 + tie);
      String _concat_2 = auxNote.concat(_plus_3);
      auxNote = _concat_2;
    }
    return auxNote;
  }
  
  /**
   * Converts from Simple-Sonora chord pattern to the JFugue one.
   * 
   * @param chord Chord containing sequence of notes or base note and chord name.
   * @return String with JFugue pattern notation for chords.
   */
  public String chordToPattern(final Chord chord) {
    String auxChord = "";
    EList<Note> _chordNotes = chord.getChordNotes();
    List<Note> _list = IterableExtensions.<Note>toList(_chordNotes);
    for (final Note n : _list) {
      String _noteToPattern = this.noteToPattern(n);
      String _plus = (_noteToPattern + "+");
      String _concat = auxChord.concat(_plus);
      auxChord = _concat;
    }
    int _length = auxChord.length();
    int _minus = (_length - 1);
    String _substring = auxChord.substring(0, _minus);
    auxChord = _substring;
    String _chordName = chord.getChordName();
    boolean _notEquals = (!Objects.equal(_chordName, null));
    if (_notEquals) {
      String inversion = "";
      String _inversion = chord.getInversion();
      boolean _notEquals_1 = (!Objects.equal(_inversion, null));
      if (_notEquals_1) {
        String _inversion_1 = chord.getInversion();
        inversion = _inversion_1;
      }
      int _length_1 = auxChord.length();
      int _minus_1 = (_length_1 - 1);
      String _substring_1 = auxChord.substring(0, _minus_1);
      String _chordName_1 = chord.getChordName();
      String _plus_1 = (_substring_1 + _chordName_1);
      String _plus_2 = (_plus_1 + inversion);
      int _length_2 = auxChord.length();
      int _minus_2 = (_length_2 - 1);
      String _substring_2 = auxChord.substring(_minus_2);
      String _plus_3 = (_plus_2 + _substring_2);
      auxChord = _plus_3;
    }
    return auxChord;
  }
  
  /**
   * Converts from Simple-Sonora harmony pattern to the JFugue one.
   * 
   * @param harmony Harmony containing chord and melody notes that will be played together.
   * @return String with JFugue pattern notation for harmony.
   */
  public String harmonyToPattern(final Harmony harmony) {
    String h = "";
    EList<Note> _harmonyNotes = harmony.getHarmonyNotes();
    List<Note> _list = IterableExtensions.<Note>toList(_harmonyNotes);
    for (final Note n : _list) {
      String _noteToPattern = this.noteToPattern(n);
      String _plus = (_noteToPattern + "+");
      String _concat = h.concat(_plus);
      h = _concat;
    }
    EList<Note> _notes = harmony.getNotes();
    List<Note> _list_1 = IterableExtensions.<Note>toList(_notes);
    for (final Note n_1 : _list_1) {
      String _noteToPattern_1 = this.noteToPattern(n_1);
      String _plus_1 = (_noteToPattern_1 + "_");
      String _concat_1 = h.concat(_plus_1);
      h = _concat_1;
    }
    int _length = h.length();
    int _minus = (_length - 1);
    return h.substring(0, _minus);
  }
  
  /**
   * Converts from Simple-Sonora tuplet pattern to the JFugue one.
   * 
   * @param tuplet Tuplet containing sequence of notes and it's duration to be.
   * @return String with JFugue pattern notation for tuplet.
   */
  public String tuppletToPattern(final Tuplet tuplet) {
    EList<EObject> _tuplet = tuplet.getTuplet();
    final int numOfNotes = ((Object[])Conversions.unwrapArray(_tuplet, Object.class)).length;
    final String duration = tuplet.getDuration();
    String auxTuplet = "";
    EList<EObject> _tuplet_1 = tuplet.getTuplet();
    for (final EObject n : _tuplet_1) {
      EClass _eClass = n.eClass();
      String _name = _eClass.getName();
      switch (_name) {
        case "Note":
          String _noteToPattern = this.noteToPattern(((Note) n));
          String _plus = (_noteToPattern + "*");
          String _string = Integer.valueOf(numOfNotes).toString();
          String _plus_1 = (_plus + _string);
          String _string_1 = duration.toString();
          String _plus_2 = (_plus_1 + _string_1);
          String _plus_3 = (_plus_2 + " ");
          String _concat = auxTuplet.concat(_plus_3);
          auxTuplet = _concat;
          break;
        case "Chord":
          String _chordToPattern = this.chordToPattern(((Chord) n));
          String _plus_4 = (_chordToPattern + "*");
          String _string_2 = Integer.valueOf(numOfNotes).toString();
          String _plus_5 = (_plus_4 + _string_2);
          String _string_3 = duration.toString();
          String _plus_6 = (_plus_5 + _string_3);
          String _plus_7 = (_plus_6 + " ");
          String _concat_1 = auxTuplet.concat(_plus_7);
          auxTuplet = _concat_1;
          break;
      }
    }
    return auxTuplet;
  }
  
  /**
   * Converts Simple-Sonora to JFugue duration pattern.
   * 
   * @param dur Simple-Sonora notation for duration.
   * @return JFugue notation for duration.
   */
  public String durationToPattern(final String dur) {
    switch (dur) {
      case ":1":
        return "w";
      case ":2":
        return "h";
      case ":4":
        return "q";
      case ":8":
        return "i";
      case ":16":
        return "s";
      case ":32":
        return "t";
      case ":64":
        return "x";
      case ":128":
        return "o";
    }
    return "";
  }
  
  /**
   * Converts Simple-Sonora to JFugue accidental pattern.
   * 
   * @param acc Simple-Sonora accidental notation.
   * @return JFugue accidental notation.
   */
  public String accidentalToPattern(final String acc) {
    switch (acc) {
      case "+":
        return "#";
      case "-":
        return "b";
      case "@":
        return "n";
    }
    return acc;
  }
}
