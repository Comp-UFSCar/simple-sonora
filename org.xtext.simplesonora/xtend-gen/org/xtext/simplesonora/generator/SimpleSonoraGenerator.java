/**
 * generated by Xtext
 */
package org.xtext.simplesonora.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.io.File;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.jfugue.midi.MidiFileManager;
import org.jfugue.pattern.Pattern;
import org.jfugue.player.Player;
import org.xtext.simplesonora.simpleSonora.Chord;
import org.xtext.simplesonora.simpleSonora.Header;
import org.xtext.simplesonora.simpleSonora.Instrument;
import org.xtext.simplesonora.simpleSonora.Note;
import org.xtext.simplesonora.simpleSonora.Sequence;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class SimpleSonoraGenerator implements IGenerator {
  private String songName = new String("");
  
  private String key = new String("");
  
  private Integer curVoice = Integer.valueOf(0);
  
  private Integer curOctave = Integer.valueOf(4);
  
  private String auxNote = new String("");
  
  private String auxChord = new String("");
  
  private String curDuration = new String("h");
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    try {
      final Player player = new Player();
      final Pattern pattern = new Pattern();
      TreeIterator<EObject> _allContents = resource.getAllContents();
      Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
      Iterable<Header> _filter = Iterables.<Header>filter(_iterable, Header.class);
      for (final Header h : _filter) {
        {
          String _songName = h.getSongName();
          this.songName = _songName;
          int _tempo = h.getTempo();
          boolean _greaterThan = (_tempo > 0);
          if (_greaterThan) {
            int _tempo_1 = h.getTempo();
            pattern.setTempo(_tempo_1);
          }
          String _key = h.getKey();
          boolean _notEquals = (!Objects.equal(_key, null));
          if (_notEquals) {
            String _key_1 = h.getKey();
            String _keyToPattern = this.keyToPattern(_key_1);
            pattern.add(_keyToPattern);
          }
        }
      }
      this.curVoice = Integer.valueOf(0);
      TreeIterator<EObject> _allContents_1 = resource.getAllContents();
      Iterable<EObject> _iterable_1 = IteratorExtensions.<EObject>toIterable(_allContents_1);
      Iterable<Instrument> _filter_1 = Iterables.<Instrument>filter(_iterable_1, Instrument.class);
      for (final Instrument instrument : _filter_1) {
        {
          this.curDuration = "h";
          this.curOctave = Integer.valueOf(4);
          pattern.add(("V" + this.curVoice));
          String _instrumentName = instrument.getInstrumentName();
          String _plus = ("I[" + _instrumentName);
          String _plus_1 = (_plus + "]");
          pattern.add(_plus_1);
          EList<Sequence> _sequences = instrument.getSequences();
          for (final Sequence s : _sequences) {
            {
              Note _note = s.getNote();
              boolean _notEquals = (!Objects.equal(_note, null));
              if (_notEquals) {
                Note _note_1 = s.getNote();
                String _octave = _note_1.getOctave();
                boolean _notEquals_1 = (!Objects.equal(_octave, null));
                if (_notEquals_1) {
                  Note _note_2 = s.getNote();
                  String _octave_1 = _note_2.getOctave();
                  this.setOctave(_octave_1);
                }
                Note _note_3 = s.getNote();
                String _noteToPattern = this.noteToPattern(_note_3);
                pattern.add(_noteToPattern);
              }
              Chord _chord = s.getChord();
              boolean _notEquals_2 = (!Objects.equal(_chord, null));
              if (_notEquals_2) {
                this.auxChord = "";
                Chord _chord_1 = s.getChord();
                EList<Note> _chordNotes = _chord_1.getChordNotes();
                List<Note> _list = IterableExtensions.<Note>toList(_chordNotes);
                for (final Note n : _list) {
                  {
                    String _octave_2 = n.getOctave();
                    boolean _notEquals_3 = (!Objects.equal(_octave_2, null));
                    if (_notEquals_3) {
                      String _octave_3 = n.getOctave();
                      this.setOctave(_octave_3);
                    }
                    String _noteToPattern_1 = this.noteToPattern(n);
                    String _plus_2 = (_noteToPattern_1 + "+");
                    String _concat = this.auxChord.concat(_plus_2);
                    this.auxChord = _concat;
                  }
                }
                int _length = this.auxChord.length();
                int _minus = (_length - 1);
                String _substring = this.auxChord.substring(0, _minus);
                pattern.add(_substring);
              }
            }
          }
          this.curVoice++;
        }
      }
      player.play(pattern);
      String _string = pattern.toString();
      System.out.println(_string);
      File _file = new File((this.songName + ".mid"));
      MidiFileManager.savePatternToMidi(pattern, _file);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * Converts the Simple-Sonora key signature pattern to the JFugue pattern.
   * 
   * @param k	String containing.
   * @return String with JFugue Pattern notation for key signature.
   */
  public String keyToPattern(final String k) {
    this.key = "KEY:";
    char _charAt = k.charAt(0);
    char _upperCase = Character.toUpperCase(_charAt);
    String _string = Character.valueOf(_upperCase).toString();
    String _concat = this.key.concat(_string);
    this.key = _concat;
    char _charAt_1 = k.charAt(1);
    int _compareTo = Character.valueOf(_charAt_1).compareTo(Character.valueOf('+'));
    boolean _equals = (_compareTo == 0);
    if (_equals) {
      String _concat_1 = this.key.concat("#");
      this.key = _concat_1;
    } else {
      char _charAt_2 = k.charAt(1);
      int _compareTo_1 = Character.valueOf(_charAt_2).compareTo(Character.valueOf('-'));
      boolean _equals_1 = (_compareTo_1 == 0);
      if (_equals_1) {
        String _concat_2 = this.key.concat("b");
        this.key = _concat_2;
      }
    }
    String _substring = k.substring(2);
    String _trim = _substring.trim();
    String _concat_3 = this.key.concat(_trim);
    this.key = _concat_3;
    return this.key;
  }
  
  /**
   * Changes the current octave accordingly to the octave operator used.
   * 
   * @param o String containing the octave information.
   */
  public void setOctave(final String o) {
    int _compareTo = o.compareTo(">");
    boolean _equals = (_compareTo == 0);
    if (_equals) {
      this.curOctave++;
    } else {
      int _compareTo_1 = o.compareTo("<");
      boolean _equals_1 = (_compareTo_1 == 0);
      if (_equals_1) {
        this.curOctave--;
      } else {
        char _charAt = o.charAt(1);
        String _string = Character.valueOf(_charAt).toString();
        int _parseInt = Integer.parseInt(_string);
        this.curOctave = Integer.valueOf(_parseInt);
      }
    }
  }
  
  /**
   * Converts from Simple-Sonora note pattern to the JFugue one.
   * 
   * @param note Note containing note id, accidental and duration.
   * @return String with JFugue pattern notation for notes.
   */
  public String noteToPattern(final Note note) {
    String _note = note.getNote();
    String _upperCase = _note.toUpperCase();
    this.auxNote = _upperCase;
    String _accidental = note.getAccidental();
    boolean _notEquals = (!Objects.equal(_accidental, null));
    if (_notEquals) {
      String _accidental_1 = note.getAccidental();
      String _accidentalToPattern = this.accidentalToPattern(_accidental_1);
      String _concat = this.auxNote.concat(_accidentalToPattern);
      this.auxNote = _concat;
    }
    String _duration = note.getDuration();
    boolean _notEquals_1 = (!Objects.equal(_duration, null));
    if (_notEquals_1) {
      String _duration_1 = note.getDuration();
      String _durationToPattern = this.durationToPattern(_duration_1);
      this.curDuration = _durationToPattern;
    }
    String point = "";
    boolean _isPoint = note.isPoint();
    if (_isPoint) {
      point = ".";
    }
    String _string = this.curOctave.toString();
    String _plus = (_string + this.curDuration);
    String _plus_1 = (_plus + point);
    String _concat_1 = this.auxNote.concat(_plus_1);
    this.auxNote = _concat_1;
    return this.auxNote;
  }
  
  /**
   * Converts Simple-Sonora to JFugue duration pattern.
   * 
   * @param dur Simple-Sonora notation for duration.
   * @return JFugue notation for duration.
   */
  public String durationToPattern(final String dur) {
    switch (dur) {
      case ":1":
        return "w";
      case ":2":
        return "h";
      case ":4":
        return "q";
      case ":8":
        return "i";
      case ":16":
        return "s";
      case ":32":
        return "t";
      case ":64":
        return "x";
      case ":128":
        return "o";
    }
    return "";
  }
  
  /**
   * Converts Simple-Sonora to JFugue accidental pattern.
   * 
   * @param acc Simple-Sonora accidental notation.
   * @return JFugue accidental notation.
   */
  public String accidentalToPattern(final String acc) {
    switch (acc) {
      case "+":
        return "#";
      case "-":
        return "b";
      case "@":
        return "n";
    }
    return acc;
  }
}
